// 支持对Time列的等值的INNER JOIN查询
// INNER 关键字可省略
// 内连接，返回两个表中连接条件的记录，等同于两个表的交集


connect root/root;
--0.清理数据：
drop database test_db;
<<NULL;

--1. 创建数据库
create database test_db;

--2. 指定数据库
use test_db;

--3. 创建表
create table students
(
    region STRING ID,
	student_id INT32 MEASUREMENT,
	name STRING MEASUREMENT,
	genders text MEASUREMENT,
    date_of_birth DATE MEASUREMENT 
);

create table teachers
(
    region STRING ID,
	teacher_id INT32 MEASUREMENT,
    course_id INT32 MEASUREMENT,
    age INT32 MEASUREMENT
);

create table courses
(
    course_id STRING ID,
	course_name STRING MEASUREMENT,
	teacher_id INT32 MEASUREMENT
);

create table grades
(
    grade_id STRING ID,
	course_id INT32 MEASUREMENT,
	student_id INT32 MEASUREMENT,
	score INT32 MEASUREMENT
);

--4. 查看表
show tables;

--5. 展示表结构信息
desc students;
desc teachers;
desc courses;
desc grades;

--6. 分别插入数据
insert into students(time,region,student_id,name,genders,date_of_birth) values
(1,'haidian',1,'Lucy','女','2015-10-10'),
(2,'haidian',2,'Jack','男','2015-09-24'),
(3,'chaoyang',3,'Sam','男','2014-07-20'),
(4,'chaoyang',4,'Lily','女','2015-03-28'),
(5,'xicheng',5,'Helen','女','2016-01-22'),
(6,'changping',6,'Nancy','女','2017-12-20'),
(7,'changping',7,'Mike','男','2016-11-22'),
(8,'shunyi',8,'Bob','男','2016-05-12');

insert into teachers(time,region,teacher_id,course_id,age) values
(1,'haidian',1001,10000001,25),
(2,'haidian',1002,10000002,26),
(3,'chaoyang',1003,10000003,28),
(4,'chaoyang',1004,10000004,27),
(5,'xicheng',1005,10000005,26);

insert into courses(time,course_id,course_name,teacher_id) values
(1,10000001,'数学',1001),
(2,10000002,'语文',1002),
(3,10000003,'英语',1003),
(4,10000004,'体育',1004),
(5,10000005,'历史',1005);

insert into grades(time,grade_id,course_id,student_id,score) values
(1,1111,10000001,1,99),
(2,1112,10000002,2,90),
(3,1113,10000003,3,85),
(4,1114,10000004,4,89),
(5,1115,10000005,5,98),
(6,1113,10000003,6,55),
(7,1114,10000004,7,60),
(8,1115,10000005,8,100),
(9,1114,10000001,2,99),
(10,1115,10000002,1,95);

--7. 分别查询表数据
select * from students order by time;
select * from teachers order by time;
select * from courses order by time;
select * from grades order by time;


--8. 显式指定连接条件

--8.1 非 Time列的等值多表查询（暂不支持）
select  
    s.name as student_name,
    c.course_name,
    g.score
from 
    students s
INNER JOIN 
    grades g on s.student_id = g.student_id
INNER JOIN 
    courses c on g.course_id = c.course_id
ORDER BY 
    s.student_id;
 <<SQLSTATE;

 --8.2 Time列的等值连接 JOIN + ON 连接
select 
  s.time, 
  s.region as region1, 
  s.student_id as id1, 
  t.region as region2, 
  t.teacher_id as id2 
from
  students s 
JOIN teachers t ON s.time = t.time;

select 
   t.teacher_id,
   course_name
from 
    teachers t
JOIN 
    courses c ON t.time = c.time;

select
	s.time,
	s.region as stu_region,
	s.name as stu_name,
	t.region as tea_region,
	c.course_name,
	g.score
from students s 
JOIN teachers t ON s.time=t.time 
JOIN courses c ON c.time=t.time 
JOIN grades g ON g.time=c.time;

select 
	count(s.region) as region_count,
	count(s.student_id) as student_id_count,
	count(t.teacher_id) as teacher_id_count,
	count(c.course_id) as course_id_count,
	avg(g.score) as avg_score,
	max(g.score) as max_score,
	min(g.score) as min_score
from students s 
JOIN teachers t ON s.time=t.time 
JOIN courses c ON c.time=t.time 
JOIN grades g ON g.time=c.time;

select 
    s.name,
    g.score,
    CASE 
        WHEN g.score >= 90 THEN 'A'
        WHEN g.score >= 80 THEN 'B'
        WHEN g.score >= 70 THEN 'C'
        WHEN g.score >= 60 THEN 'D'
        ELSE 'F'
    END AS grade,
    CASE 
        WHEN g.score >= 60 THEN 'Pass'
        ELSE 'Fail'
    END AS status,
    CASE 
        WHEN g.score >= 85 THEN 'Excellent'
        WHEN g.score >= 70 THEN 'Good'
        WHEN g.score >= 50 THEN 'Average'
        ELSE 'Needs Improvement'
    END AS performance
from 
    students s
JOIN 
    grades g ON s.time = g.time;

select 
	s.region,
	s.name,
	t.teacher_id,
	c.course_id,
	c.course_name,
	g.score
from students s 
JOIN teachers t ON s.time=t.time 
JOIN courses c ON c.time=t.time 
JOIN grades g ON g.time=c.time
where s.time > 2 and s.time < 6;

--8.3 Time列的 JOIN + USING 连接
select time from grades g INNER JOIN courses c USING(time);

select s.student_id, s.name, t.teacher_id, t.course_id from students s INNER JOIN teachers t USING(time);

select
	s.region,
	s.genders as "性别",
    s.name as "学生姓名",
    t.teacher_id as "教师编号",
    t.age as "年龄",
    c.course_id as "课程编号",
    c.course_name as "课程名",
    g.score as "学生成绩"
from 
    students s
INNER JOIN 
    teachers t USING (time)
INNER JOIN
	courses c USING (time)
INNER JOIN
	grades g USING (time);

select
	count(s.region) as region_count,
    count(s.student_id) as student_id_count,
    count(t.teacher_id) as teacher_id_count,
    count(c.course_id) as course_id_count,
    avg(g.score) as avg_score,
    max(g.score) as max_score,
    last(g.score) as last_score
from 
    students s
INNER JOIN 
    teachers t USING (time)
INNER JOIN
	courses c USING (time)
INNER JOIN
	grades g USING (time)
where time > 2 and time <6;


--9. 隐式指定条件：不需要出现JOIN | ON | USING，通过WHERE子句指定条件来实现表与表之间连接
select c.time, 
       c.course_id as id_1, c.course_name as name,
       g.grade_id as id_2, g.score as score 
from 
courses c, grades g
where
c.time=g.time;

select s.time,
	   s.student_id as s_id, s.name as s_name, s.date_of_birth as s_birth,
	   t.teacher_id as t_id, t.course_id as t_c_id,
       c.course_name as c_name,
       g.grade_id as g_id, g.score as score 
from 
students s, teachers t, courses c, grades g
where
s.time=t.time AND c.time=g.time AND s.time=c.time;

select s.time,
	   count(s.student_id) as s_id_count,
	   count(t.teacher_id) as t_id_count,
       count(c.course_id) as c_name_count,
       avg(g.score) as score_count, sum(g.score) as score_sum
from 
students s, teachers t, courses c, grades g
where
s.time=t.time AND c.time=g.time AND s.time=c.time 
group by s.time;

select s.time,
	   s.name,
	   c.course_name,
	   g.score,
	   case
	   		when g.score =100 then 'Excellent'
	   		when g.score >=85 then 'Great'
	   		when g.score >=60 then 'Not Bad'
	   		else 'Keep Going'
	   end as grade,
	   case
	   		when avg(g.score) > 60 then 'PASS'
	   		else 'FAIL'
	   	end as status
from students s, courses c, grades g
where
s.time=c.time and c.time=g.time 
group by s.time,s.name, c.course_name,g.score;

select s.student_id,
	   t.teacher_id,
	   c.course_name,
	   max(g.score) as highest_score,
	   min(g.score) as lowest_score
from students s, teachers t, courses c, grades g
where
s.time=t.time and t.time=c.time and c.time=g.time 
group by s.student_id, t.teacher_id, c.course_name;


-- 清理数据： 删除数据库 
drop database test_db;
<<NULL;